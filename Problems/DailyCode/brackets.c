```c
#include <stdio.h>
#include <string.h>

// 프로그램 설명:
// 이 프로그램은 주어진 문자열 S가 올바르게 중첩된 문자열인지 검사합니다.
// 올바르게 중첩된 문자열의 조건은 다음과 같습니다:
// 1. S가 빈 문자열일 경우.
// 2. S가 "(U)", "[U]", "{U}" 형태일 경우, 여기서 U는 올바르게 중첩된 문자열.
// 3. S가 "VW" 형태일 경우, 여기서 V와 W는 각각 올바르게 중첩된 문자열.
// 예를 들어, "{[()()]}"는 올바르게 중첩된 문자열이지만, "([)()]"는 그렇지 않습니다.
//
// 함수 설명:
// int solution(char *S);
// 주어진 문자열 S가 올바르게 중첩된 문자열이면 1을, 아니면 0을 반환합니다.
//
// 입력 제약조건:
// - N은 0 이상 200,000 이하의 정수.
// - 문자열 S는 '(', ')', '{', '}', '[', ']' 문자로만 구성됨.

int solution(char *S) {
    // 스택을 구현하기 위해 미리 최대 크기(200,000)를 할당합니다.
    // 각 스택 요소는 열림 괄호 문자를 저장합니다.
    // 스택 포인터는 현재 스택의 최상위 위치를 가리킵니다.
    char stack[200001];
    int top = -1; // 스택이 비어있음을 나타내기 위해 -1로 초기화

    // 문자열 S의 길이를 구합니다.
    int length = strlen(S);

    // 문자열의 각 문자에 대해 반복합니다.
    for(int i = 0; i < length; i++) {
        char current = S[i]; // 현재 문자를 저장

        // 만약 현재 문자가 열림 괄호라면 스택에 푸시합니다.
        if(current == '(' || current == '{' || current == '[') {
            top++; // 스택 포인터를 증가시킵니다.
            stack[top] = current; // 현재 문자를 스택에 저장
        }
        // 만약 현재 문자가 닫힘 괄호라면, 스택에서 마지막에 저장된 열림 괄호와 비교합니다.
        else if(current == ')' || current == '}' || current == ']') {
            // 스택이 비어있거나, 매칭되지 않는 괄호라면 올바르게 중첩되지 않은 것입니다.
            if(top == -1) {
                return 0; // 잘못된 중첩
            }

            char last = stack[top]; // 스택의 최상위 요소를 가져옵니다.

            // 현재 닫힘 괄호와 스택의 마지막 열림 괄호가 매칭되는지 확인합니다.
            if( (current == ')' && last == '(') ||
                (current == '}' && last == '{') ||
                (current == ']' && last == '[') ) {
                top--; // 매칭되었으므로 스택에서 제거
            }
            else {
                return 0; // 매칭되지 않으므로 잘못된 중첩
            }
        }
        // 주어진 문제의 조건에 따르면 다른 문자는 입력으로 주어지지 않으므로, else는 필요 없습니다.
    }

    // 모든 문자를 처리한 후, 스택이 비어있다면 올바르게 중첩된 문자열입니다.
    if(top == -1) {
        return 1; // 올바르게 중첩됨
    }
    else {
        return 0; // 스택에 남은 열림 괄호가 있으므로 잘못 중첩됨
    }
}

// 테스트를 위한 메인 함수 (옵션):
// 아래의 main 함수는 예제 입력을 테스트하기 위해 사용할 수 있습니다.
// 실제 제출 시에는 필요하지 않을 수 있습니다.

int main() {
    // 테스트 케이스 배열
    char *test_cases[] = {
        "{[()()]}", // 올바르게 중첩됨: 예상 결과 1
        "([)()]",   // 잘못 중첩됨: 예상 결과 0
        "",         // 빈 문자열: 예상 결과 1
        "(",        // 열림 괄호만: 예상 결과 0
        ")",        // 닫힘 괄호만: 예상 결과 0
        "{[()]}()", // 올바르게 중첩됨: 예상 결과 1
        "{[(])}",   // 잘못 중첩됨: 예상 결과 0
        "{{{{",     // 열림 괄호만 여러 개: 예상 결과 0
        "}}}}",     // 닫힘 괄호만 여러 개: 예상 결과 0
        "{[()()]}}",// 마지막에 닫힘 괄호 하나 더: 예상 결과 0
    };

    // 예상 결과 배열
    int expected_results[] = {1, 0, 1, 0, 0, 1, 0, 0, 0, 0};

    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);

    // 각 테스트 케이스에 대해 solution 함수를 호출하고 결과를 출력
    for(int i = 0; i < num_tests; i++) {
        int result = solution(test_cases[i]);
        printf("Test Case %d: %s\n", i+1, test_cases[i]);
        printf("Expected Result: %d, Actual Result: %d\n", expected_results[i], result);
        printf("%s\n\n", (result == expected_results[i]) ? "PASS" : "FAIL");
    }

    return 0; // 프로그램 종료
}

/*
예제 테스트 케이스 설명:
1. "{[()()]}": 모든 괄호가 올바르게 매칭되고 중첩됨. 반환 값: 1
2. "([)()]": 괄호가 올바르게 매칭되지 않음. 반환 값: 0
3. "": 빈 문자열은 올바르게 중첩됨. 반환 값: 1
4. "(": 열림 괄호만 존재. 반환 값: 0
5. ")": 닫힘 괄호만 존재. 반환 값: 0
6. "{[()]}()": 여러 괄호가 올바르게 매칭되고 중첩됨. 반환 값: 1
7. "{[(])}": 괄호가 올바르게 매칭되지 않음. 반환 값: 0
8. "{{{{": 여러 열림 괄호만 존재. 반환 값: 0
9. "}}}}": 여러 닫힘 괄호만 존재. 반환 값: 0
10. "{[()()]}}": 마지막에 닫힘 괄호가 하나 더 있어 매칭되지 않음. 반환 값: 0
*/
```
